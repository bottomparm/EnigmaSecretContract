{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1","program":"/Users/bottomparm/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rls","arguments":["--crate-name","parse_display","--edition=2018","/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata,link","-C","debuginfo=2","-C","metadata=0a712ed82df42560","-C","extra-filename=-0a712ed82df42560","--out-dir","/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps","-L","dependency=/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps","--extern","lazy_static=/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps/liblazy_static-8c46213ba833ecee.rmeta","--extern","parse_display_derive=/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps/libparse_display_derive-f3361351d932b1fd.dylib","--extern","regex=/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps/libregex-4876c0fdd4d7680b.rmeta","--cap-lints","allow","--error-format=json","--sysroot","/Users/bottomparm/.rustup/toolchains/stable-x86_64-apple-darwin"],"output":"/Users/bottomparm/Code/Web3/millionaires_problem_demo/secret_contracts/millionaires_problem/target/rls/debug/deps/libparse_display-0a712ed82df42560.rmeta"},"prelude":{"crate_id":{"name":"parse_display","disambiguator":[2108607514571045928,6356043054483628244]},"crate_root":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src","external_crates":[{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[9606925100264359032,12531971508192552739]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[17187672715010298091,8744209918715530773]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[15887813922859449425,14244592339943736272]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[6807992320260993406,9894278173044996986]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[17858480672457447890,14967053264370168355]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[1320274826319993033,12580344779796895143]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[5371179889215182298,2673167689761608764]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[3578723082929147264,11802062942665263000]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[12064590987128239469,16657797211233097221]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[9585105124653066898,10355053755662228341]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":11,"id":{"name":"backtrace_sys","disambiguator":[168442059660610991,16640229565854074068]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":12,"id":{"name":"hashbrown","disambiguator":[13744766486950275495,4356178648036430150]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":13,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[4695427281829409190,666464352563047434]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":14,"id":{"name":"panic_unwind","disambiguator":[825342386373460966,7285997970727292365]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":15,"id":{"name":"lazy_static","disambiguator":[8558109754389694127,4961123605618878474]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":16,"id":{"name":"regex","disambiguator":[15004111403379984471,5383072744286130369]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":17,"id":{"name":"aho_corasick","disambiguator":[17741816216257489062,3799006797400683147]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":18,"id":{"name":"memchr","disambiguator":[12401141559839969798,9021894814346263670]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":19,"id":{"name":"regex_syntax","disambiguator":[5580169698090659106,1859254464487265936]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":20,"id":{"name":"thread_local","disambiguator":[6927359287351781498,271490640183430283]}},{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","num":21,"id":{"name":"parse_display_derive","disambiguator":[17764138754739282086,16509666642955330649]}}],"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":0,"byte_end":12357,"line_start":1,"line_end":499,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":15,"index":0},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11836,"byte_end":11847,"line_start":473,"line_end":473,"column_start":11,"column_end":22},"alias_span":null,"name":"lazy_static","value":"","parent":{"krate":0,"index":7}},{"kind":"Use","ref_id":{"krate":16,"index":0},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11859,"byte_end":11864,"line_start":474,"line_end":474,"column_start":11,"column_end":16},"alias_span":null,"name":"regex","value":"","parent":{"krate":0,"index":7}},{"kind":"Use","ref_id":{"krate":21,"index":57},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11900,"byte_end":11907,"line_start":477,"line_end":477,"column_start":32,"column_end":39},"alias_span":null,"name":"Display","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":21,"index":67},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11909,"byte_end":11916,"line_start":477,"line_end":477,"column_start":41,"column_end":48},"alias_span":null,"name":"FromStr","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":0,"byte_end":12357,"line_start":1,"line_end":499,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":7},{"krate":0,"index":10},{"krate":0,"index":20},{"krate":0,"index":30},{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":23},{"krate":0,"index":24},{"krate":0,"index":13},{"krate":0,"index":16},{"krate":0,"index":18}],"decl_id":null,"docs":"This crate provides derive macro `Display` and `FromStr`.\nThese macros use common helper attributes to specify the format.","sig":null,"attributes":[{"value":"!\nThis crate provides derive macro `Display` and `FromStr`.\nThese macros use common helper attributes to specify the format.\n\n## Install\n\nAdd this to your Cargo.toml:\n```toml\n[dependencies]\nparse-display = \"0.1\"\n```\n\n## Example\n\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"{a}-{b}\")]\nstruct MyStruct {\n  a: u32,\n  b: u32,\n}\nassert_eq!(MyStruct { a:10, b:20 }.to_string(), \"10-20\");\nassert_eq!(\"10-20\".parse(), Ok(MyStruct { a:10, b:20 }));\n\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(style = \"snake_case\")]\nenum MyEnum {\n  VarA,\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"var_a\");\nassert_eq!(\"var_a\".parse(), Ok(MyEnum::VarA));\n```\n\n## Helper attributes\n\nHelper attributes can be written in the following positions.\n\n|                           attribute                           | struct | enum | variant | field |\n| ------------------------------------------------------------- | ------ | ---- | ------- | ----- |\n| [`#[display(\"...\")]`](#display)                               | ✔      | ✔    | ✔       | ✔     |\n| [`#[display(style = \"...\")]`](#displaystyle--)                |        | ✔    | ✔       |       |\n| [`#[from_str(regex = \"...\")]`](#from_strregex--)              | ✔      | ✔    | ✔       | ✔     |\n| [`#[from_str(default)]`](#from_strdefault)                    | ✔      | ✔    |         | ✔     |\n| [`#[from_str(default_fields(...))]`](#from_strdefault_fields) | ✔      | ✔    | ✔       |       |\n\n`#[derive(Display)]` use `#[display]`.\n`#[derive(FromStr)]` use both `#[display]` and `#[from_str]`.\n\n## `#[display(\"...\")]`\n\nSpecifies the format using a syntax similar to [`std::format!()`].\nHowever, unlike `std::format!()`, field name is specified in `{}`.\n\n### Struct format\nBy writing `#[display(\"..\")]`, you can specify the format used by `Display` and `FromStr`.\n\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"{a}-{b}\")]\nstruct MyStruct {\n  a: u32,\n  b: u32,\n}\nassert_eq!(MyStruct { a:10, b:20 }.to_string(), \"10-20\");\nassert_eq!(\"10-20\".parse(), Ok(MyStruct { a:10, b:20 }));\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"{0}+{1}\")]\nstruct MyTuple(u32, u32);\nassert_eq!(MyTuple(10, 20).to_string(), \"10+20\");\nassert_eq!(\"10+20\".parse(), Ok(MyTuple(10, 20)));\n```\n\n### Newtype pattern\n\nIf the struct has only one field, the format can be omitted.\nIn this case, the only field is used.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nstruct NewType(u32);\nassert_eq!(NewType(10).to_string(), \"10\");\nassert_eq!(\"10\".parse(), Ok(NewType(10)));\n```\n\n### Enum format\nIn enum, you can specify the format for each variant.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nenum MyEnum {\n  #[display(\"aaa\")]\n  VarA,\n  #[display(\"bbb\")]\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"aaa\");\nassert_eq!(MyEnum::VarB.to_string(), \"bbb\");\nassert_eq!(\"aaa\".parse(), Ok(MyEnum::VarA));\nassert_eq!(\"bbb\".parse(), Ok(MyEnum::VarB));\n```\n\nIn enum format, `{}` means variant name.\nVariant name style (e.g. snake_case, camelCase, ...)  can be specified by [`#[from_str(style = \"...\")]`](#displaystyle--).\n\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nenum MyEnum {\n  #[display(\"aaa-{}\")]\n  VarA,\n  #[display(\"bbb-{}\")]\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"aaa-VarA\");\nassert_eq!(MyEnum::VarB.to_string(), \"bbb-VarB\");\nassert_eq!(\"aaa-VarA\".parse(), Ok(MyEnum::VarA));\nassert_eq!(\"bbb-VarB\".parse(), Ok(MyEnum::VarB));\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(style = \"snake_case\")]\nenum MyEnumSnake {\n  #[display(\"{}\")]\n  VarA,\n}\nassert_eq!(MyEnumSnake::VarA.to_string(), \"var_a\");\nassert_eq!(\"var_a\".parse(), Ok(MyEnumSnake::VarA));\n```\n\nBy writing a format on enum instead of variant, you can specify the format common to multiple variants.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"xxx-{}\")]\nenum MyEnum {\n  VarA,\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"xxx-VarA\");\nassert_eq!(MyEnum::VarB.to_string(), \"xxx-VarB\");\nassert_eq!(\"xxx-VarA\".parse(), Ok(MyEnum::VarA));\nassert_eq!(\"xxx-VarB\".parse(), Ok(MyEnum::VarB));\n```\n\n### Unit variants\n\nIf all variants has no field, format can be omitted.\nIn this case, variant name is used.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nenum MyEnum {\n  VarA,\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"VarA\");\nassert_eq!(MyEnum::VarB.to_string(), \"VarB\");\nassert_eq!(\"VarA\".parse(), Ok(MyEnum::VarA));\nassert_eq!(\"VarB\".parse(), Ok(MyEnum::VarB));\n```\n\n### Field format\nYou can specify the format of the field.\nIn field format, `{}` means the field itself.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"{a}, {b}\")]\nstruct MyStruct {\n  #[display(\"a is {}\")]\n  a: u32,\n  #[display(\"b is {}\")]\n  b: u32,\n}\nassert_eq!(MyStruct { a:10, b:20 }.to_string(), \"a is 10, b is 20\");\nassert_eq!(\"a is 10, b is 20\".parse(), Ok(MyStruct { a:10, b:20 }));\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(\"{0}, {1}\")]\nstruct MyTyple(#[display(\"first is {}\")] u32, #[display(\"next is {}\")] u32);\nassert_eq!(MyTyple(10, 20).to_string(), \"first is 10, next is 20\");\nassert_eq!(\"first is 10, next is 20\".parse(), Ok(MyTyple(10, 20)));\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nenum MyEnum {\n  #[display(\"this is A {0}\")]\n  VarA(#[display(\"___{}___\")] u32),\n}\nassert_eq!(MyEnum::VarA(10).to_string(), \"this is A ___10___\");\nassert_eq!(\"this is A ___10___\".parse(), Ok(MyEnum::VarA(10)));\n```\n\n### Field chain\n\nYou can use \"field chain\", e.g. `{x.a}` .\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(PartialEq, Debug, Default)]\nstruct MyStruct {\n  a: u32,\n  b: u32,\n}\n\n#[derive(FromStr, Display, PartialEq, Debug)]\n#[display(\"{x.a}\")]\nstruct FieldChain {\n  #[from_str(default)]\n  x: MyStruct,\n}\nassert_eq!(FieldChain { x:MyStruct { a:10, b:20 } }.to_string(), \"10\");\nassert_eq!(\"10\".parse(), Ok(FieldChain { x:MyStruct { a:10, b:0 } }));\n```\nWhen using \"field chain\", you need to use [`#[from_str(default)]`](#from_strdefault) to implement `FromStr`.\n\n\n### Format parameter\nLike `std::format!()`, format parameter can be specified.\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, PartialEq, Debug)]\n#[display(\"{a:>04}\")]\nstruct WithFormatParameter {\n  a: u32,\n}\nassert_eq!(WithFormatParameter { a:5 }.to_string(), \"0005\");\n```\n\n## `#[display(style = \"...\")]`\nBy writing `#[display(style = \"..\")]`, you can specify the variant name style.\nThe following styles are available.\n\n- none\n- lowercase\n- UPPERCASE\n- snake_case\n- SNAKE_CASE\n- camelCase\n- CamelCase\n- kebab-case\n- KEBAB-CASE\n\n```rust\nuse parse_display::{Display, FromStr};\n\n#[derive(Display, FromStr, PartialEq, Debug)]\n#[display(style = \"snake_case\")]\nenum MyEnum {\n  VarA,\n  VarB,\n}\nassert_eq!(MyEnum::VarA.to_string(), \"var_a\");\nassert_eq!(\"var_a\".parse(), Ok(MyEnum::VarA));\n\n#[derive(Display, FromStr, PartialEq, Debug)]\nenum StyleExample {\n  #[display(style = \"none\")]\n  VarA1,\n  #[display(style = \"none\")]\n  varA2,\n  #[display(style = \"lowercase\")]\n  VarB,\n  #[display(style = \"UPPERCASE\")]\n  VarC,\n  #[display(style = \"snake_case\")]\n  VarD,\n  #[display(style = \"SNAKE_CASE\")]\n  VarE,\n  #[display(style = \"camelCase\")]\n  VarF,\n  #[display(style = \"CamelCase\")]\n  VarG1,\n  #[display(style = \"CamelCase\")]\n  varG2,\n  #[display(style = \"kebab-case\")]\n  VarH,\n  #[display(style = \"KEBAB-CASE\")]\n  VarI,\n}\nassert_eq!(StyleExample::VarA1.to_string(), \"VarA1\");\nassert_eq!(StyleExample::varA2.to_string(), \"varA2\");\nassert_eq!(StyleExample::VarB.to_string(), \"varb\");\nassert_eq!(StyleExample::VarC.to_string(), \"VARC\");\nassert_eq!(StyleExample::VarD.to_string(), \"var_d\");\nassert_eq!(StyleExample::VarE.to_string(), \"VAR_E\");\nassert_eq!(StyleExample::VarF.to_string(), \"varF\");\nassert_eq!(StyleExample::VarG1.to_string(), \"VarG1\");\nassert_eq!(StyleExample::varG2.to_string(), \"VarG2\");\nassert_eq!(StyleExample::VarH.to_string(), \"var-h\");\nassert_eq!(StyleExample::VarI.to_string(), \"VAR-I\");\n```\n\n## `#[from_str(regex = \"...\")]`\n\nSpecify the format of the string to be input with `FromStr`.\n `#[display(\"...\")]` is ignored, when this attribute is specified.\n\n### Capture name\n\nThe capture name corresponds to the field name.\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[from_str(regex = \"(?P<a>[0-9]+)__(?P<b>[0-9]+)\")]\nstruct MyStruct {\n  a: u8,\n  b: u8,\n}\n\nassert_eq!(\"10__20\".parse(), Ok(MyStruct { a:10, b:20 }));\n```\n\n### Field regex\n\nSet `#[display(\"...\")]` to struct and set `#[from_str(regex = \"...\")]` to field, regex is used in the position where field name is specified in `#[display(\"...\")]`.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[display(\"{a}__{b}\")]\nstruct MyStruct {\n  #[from_str(regex = \"[0-9]+\")]\n  a: u8,\n\n  #[from_str(regex = \"[0-9]+\")]\n  b: u8,\n}\nassert_eq!(\"10__20\".parse(), Ok(MyStruct { a:10, b:20 }));\n```\n\nIf `#[from_str(regex = \"...\")]` is not set to field ,\nit operates in the same way as when `#[from_str(regex = \".*?\")]` is set.\n\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[display(\"{a}{b}\")]\nstruct MyStruct {\n  a: String,\n  b: String,\n}\nassert_eq!(\"abcdef\".parse(), Ok(MyStruct { a:\"\".into(), b:\"abcdef\".into() }));\n```\n\n### Variant name\n\nIn the regex speficied for enum or variant, empty name capture means variant name.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[from_str(regex = \"___(?P<>)___\")]\nenum MyEnum {\n  VarA,\n\n  #[from_str(regex = \"xxx(?P<>)xxx\")]\n  VarB,\n}\nassert_eq!(\"___VarA___\".parse(), Ok(MyEnum::VarA));\nassert_eq!(\"xxxVarBxxx\".parse(), Ok(MyEnum::VarB));\n```\n\n### Field chain\n\nYou can use \"field chain\" in regex.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(PartialEq, Debug, Default)]\nstruct MyStruct {\n  a: u32,\n}\n\n#[derive(FromStr, PartialEq, Debug)]\n#[from_str(regex = \"___(?P<x.a>[0-9]+)\")]\nstruct FieldChain {\n  #[from_str(default)]\n  x: MyStruct,\n}\nassert_eq!(\"___10\".parse(), Ok(FieldChain { x:MyStruct { a:10 } }));\n```\n\nWhen using \"field chain\", you need to use [`#[from_str(default)]`](#from_strdefault).\n\n## `#[from_str(default)]`\n\nIf this attribute is specified, the default value is used for fields not included in the input.\n\nIf an attribute is specified for struct, the struct's default value is used.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[display(\"{b}\")]\n#[from_str(default)]\nstruct MyStruct {\n  a: u32,\n  b: u32,\n}\n\nimpl Default for MyStruct {\n  fn default() -> Self {\n    Self { a:99, b:99 }\n  }\n}\nassert_eq!(\"10\".parse(), Ok(MyStruct { a:99, b:10 }));\n```\n\nIf an attribute is specified for field, the field type's default value is used.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[display(\"{b}\")]\nstruct MyStruct {\n  #[from_str(default)]\n  a: u32,\n  b: u32,\n}\n\nimpl Default for MyStruct {\n  fn default() -> Self {\n    Self { a:99, b:99 }\n  }\n}\nassert_eq!(\"10\".parse(), Ok(MyStruct { a:0, b:10 }));\n```\n\n## `#[from_str(default_fields(...))]`\n\nYou can use `#[from_str(default_fields(...))]` if you want to set default values for the same-named fields of multiple variants.\n\n```rust\nuse parse_display::FromStr;\n\n#[derive(FromStr, PartialEq, Debug)]\n#[display(\"{}-{a}\")]\n#[from_str(default_fields(\"b\", \"c\"))]\nenum MyEnum {\n  VarA { a:u8, b:u8, c:u8 },\n  VarB { a:u8, b:u8, c:u8 },\n}\n\nassert_eq!(\"VarA-10\".parse(), Ok(MyEnum::VarA { a:10, b:0, c:0 }));\nassert_eq!(\"VarB-10\".parse(), Ok(MyEnum::VarB { a:10, b:0, c:0 }));\n```\n*/","span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":0,"byte_end":11761,"line_start":1,"line_end":468,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":7},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11816,"byte_end":11823,"line_start":472,"line_end":472,"column_start":9,"column_end":16},"name":"helpers","qualname":"::helpers","value":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","parent":null,"children":[{"krate":0,"index":8},{"krate":0,"index":9}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":20},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11963,"byte_end":11973,"line_start":480,"line_end":480,"column_start":12,"column_end":22},"name":"ParseError","qualname":"::ParseError","value":"","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":14},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12016,"byte_end":12028,"line_start":482,"line_end":482,"column_start":10,"column_end":22},"name":"with_message","qualname":"<ParseError>::with_message","value":"fn (message: &'static str) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":15},"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12093,"byte_end":12096,"line_start":485,"line_end":485,"column_start":10,"column_end":13},"name":"new","qualname":"<ParseError>::new","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Inherent","span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11994,"byte_end":12004,"line_start":481,"line_end":481,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":14},{"krate":0,"index":15}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12173,"byte_end":12183,"line_start":490,"line_end":490,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":17}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12294,"byte_end":12304,"line_start":495,"line_end":495,"column_start":28,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":19}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":11994,"byte_end":12004,"line_start":481,"line_end":481,"column_start":6,"column_end":16},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":20},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12173,"byte_end":12183,"line_start":490,"line_end":490,"column_start":18,"column_end":28},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":5921}},{"span":{"file_name":"/Users/bottomparm/.cargo/registry/src/github.com-1ecc6299db9ec823/parse-display-0.1.1/src/lib.rs","byte_start":12294,"byte_end":12304,"line_start":495,"line_end":495,"column_start":28,"column_end":38},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":20},"to":{"krate":1,"index":1620}}]}